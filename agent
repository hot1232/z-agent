#!/usr/bin/env python2.7
# -*- coding:utf8 -*-

from gevent import monkey
monkey.patch_all()

import gevent
from gevent.threadpool import ThreadPool
from gevent.pool import Pool
from gevent.server import StreamServer
from socket import error as socket_error
import imp
import os
import signal

import checker
import sender.zbx
from lib.link import Chanels


class Collector(object):
    def __new__(cls, *args, **kw):  
        if not hasattr(cls, '_instance'):  
            orig = super(Collector, cls)  
            cls._instance = orig.__new__(cls, *args, **kw)  
        return cls._instance    
    def __init__(self,collecttype="checker"):
        self.mod_list={}
        curdir=os.path.dirname(os.path.realpath(__file__))
        for cwd,subdirs,files in os.walk(os.path.join(curdir,collecttype)):
            import_prefix=collecttype
            for mod in files:
                if mod.endswith(".py") and mod != "__init__.py":
                    mod_name="%s.%s"%(import_prefix,mod.rstrip(".py"))
                    file, pathname, desc = imp.find_module(mod.rstrip(".py"),[os.path.join(curdir,cwd)])
                    self.mod_list[mod.rstrip(".py")]=imp.load_module(mod_name,file,pathname,desc)        
    
    def __iter__(self):
        return iter(self.mod_list.keys())
    def __getitem__(self,key):
        if key in self.mod_list:
            return self.mod_list[key]
        else:
            self.__iter__()
    
class CommandRunner(object):
    def __init__(self):
        pass
    def __call__(self,socket, address):
        try:
            socket.settimeout(30)
            while not socket.closed:
                #需要添加身份认证
                data=socket.recv(1024)
                socket.sendall('HTTP/1.1 200 OK\n\npid: %s count: %s  data: %s!!\n'%(os.getpid(),self.count,data))
            socket.close()
        except socket_error,e:
            (errno,msg)=e
            print("error %s: %s"%(errno,msg))
            if not socket.closed:
                socket.close()
        
    @staticmethod
    def serve_forever():
        __doc__ = '''
        多进程时使用
        '''
        server.start()
        server.start_accepting()
        server._stop_event.wait()
        

class ResultsSender(gevent.Greenlet):
    def __init__(self,*args,**kwargs):
        super(ResultsSender,self).__init__(*args,**kwargs)
        
    def _run(self,*args,**kwargs):
        chan = Chanels()
        if not "checker_result_queue" in chan:
            chan.append("checker_result_queue")
        self.cls_sender=self.kwargs.get("sender")
        self.kwargs.pop("sender")
        sender=self.cls_sender(*(),**self.kwargs)
        chan=Chanels()
        while True:
            data={}
            try:
                count=0
                while not chan["checker_result_queue"].empty():
                    if count == 20:
                        break
                    data=chan["checker_result_queue"].get()
                    data.update(data)
                    count+=1
                timeout=gevent.Timeout(3)
                timeout.start()
                if not data == {}:
                    sender.send(data)
                timeout.cancel()
            except gevent.Timeout,e:
                print("%s"%e)
                continue
            gevent.sleep(60)
                

class Agent(object):
    def __init__(self,**kwarg):
        self.checker_list=[]
        self.server=None
        self.sender=None
        for k,v in kwarg.items():
            setattr(self, k, v)
    
    def run_checker(self):
        #start worker thread pool
        #这段代码需要再分析一下
        
        cc=Collector()
        
        for checker in cc:
            ck=cc[checker].Checker()
            #非单例的使用方式
            #ck2=cc[checker].Checker(_name="test")
            ck.spawn()
            self.checker_list.append(ck)        
    
    def run_facter(self):
        cc=Collector(collecttype="facter")
        for facter in cc:
            fact=cc[facter].Facter()
            #not complete!
        pass
    
    def run_zbxtrapsender(self):
        self.sender=ResultsSender()
        self.sender.spawn(sender=sender.zbx.Sender,mType="items")
    
    def run_cmdserver(self):
        #需要添加配置读取代码
        self.server = StreamServer(('',10052), CommandRunner(), backlog=100000)
        self.server.init_socket()
        
        gevent.signal(signal.SIGQUIT, self.gevent_shutdown,self.checker_list,self.server,self.sender)
        gevent.signal(signal.SIGINT,self.gevent_shutdown,self.checker_list,self.server,self.sender)    
        
        self.server.start()
        self.server.start_accepting()
        self.server._stop_event.wait()
    
    def gevent_shutdown(self,checker_list,server,sender):
        gevent.killall(self.checker_list)
        server.stop()
        gevent.killall([sender])
    
    @classmethod
    def main(self):
        agent=Agent()
        agent.run_checker()
        agent.run_zbxtrapsender()
        #seagentlf.run_facter()
        agent.run_cmdserver()
    
    
        

if __name__ == "__main__":
    Agent.main()

    
