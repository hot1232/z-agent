#!/usr/bin/env python2.7
# -*- coding:utf8 -*-

from gevent import monkey
monkey.patch_all()

import gevent
from gevent.threadpool import ThreadPool
from gevent.pool import Pool
from gevent.server import StreamServer
from socket import error as socket_error
import imp
import os
import signal
import time

import checker
import facter
import sender.zbx
from lib.link import Chanels


class Collector(object):
    def __new__(cls, *args, **kw):  
        if not hasattr(cls, '_instance'):  
            orig = super(Collector, cls)  
            cls._instance = orig.__new__(cls, *args, **kw)  
        return cls._instance    
    def __init__(self,collecttype="checker"):
        self.mod_list={}
        curdir=os.path.dirname(os.path.realpath(__file__))
        for cwd,subdirs,files in os.walk(os.path.join(curdir,collecttype)):
            import_prefix=collecttype
            for mod in files:
                if mod.endswith(".py") and mod != "__init__.py":
                    mod_name="%s.%s"%(import_prefix,mod.rstrip(".py"))
                    file, pathname, desc = imp.find_module(mod.rstrip(".py"),[os.path.join(curdir,cwd)])
                    self.mod_list[mod.rstrip(".py")]=imp.load_module(mod_name,file,pathname,desc)        
    
    def __iter__(self):
        return iter(self.mod_list.keys())
    def __getitem__(self,key):
        if key in self.mod_list:
            return self.mod_list[key]
        else:
            self.__iter__()
    
class CommandRunner(object):
    def __init__(self):
        pass
    def __call__(self,socket, address):
        try:
            socket.settimeout(30)
            while not socket.closed:
                #需要添加身份认证
                data=socket.recv(1024)
                if len(data)==0:
                    continue
                import sender.discovery
                print("recv data:%s"%data)
                send=sender.discovery.Sender(socket=socket,data="t2")
                send.send()
                socket.close()
                #socket.sendall("test")
                #socket.sendall('HTTP/1.1 200 OK\n\npid: %s  data: %s!!\n'%(os.getpid(),data))
            socket.close()
        except socket_error,e:
            (errno,msg)=e
            print("error %s: %s"%(errno,msg))
            if not socket.closed:
                socket.close()
        
    @staticmethod
    def serve_forever():
        __doc__ = '''
        多进程时使用
        '''
        server.start()
        server.start_accepting()
        server._stop_event.wait()
        

class ResultsSender(gevent.Greenlet):
    def __init__(self,*args,**kwargs):
        super(ResultsSender,self).__init__(*args,**kwargs)
        
    def _run(self,*args,**kwargs):
        chan = Chanels()
        if not "checker_result_queue" in chan:
            chan.append("checker_result_queue")
        self.cls_sender=self.kwargs.get("sender")
        self.kwargs.pop("sender")
        sender=self.cls_sender(*(),**self.kwargs)
        chan=Chanels()
        while True:
            data={}
            try:
                count=0
                while not chan["checker_result_queue"].empty():
                    if count == 20:
                        break
                    sender.add(chan["checker_result_queue"].get())
                    count+=1
                timeout=gevent.Timeout(3)
                timeout.start()
                if sender.data.items_list:
                    sender.send()
                timeout.cancel()
                gevent.sleep(60)
            except gevent.Timeout,e:
                print("timeout: %s"%e)
                continue 
class ZbxAgent(object):
    def __init__(self):
        pass
    
    def accept_system_uname(self):
        pass
    
    def accept_system_hostname(self):
        pass

class DiscoveryRunner(gevent.Greenlet):
    def __init__(self, run=None,run_interval=86400):
        super(DiscoveryRunner,self).__init__(run=run)
        self.run_interval=run_interval
        self._discovery_list={}
    
    def append(self,name,task):
        if not self._discovery_list.has_key(name):
            self._discovery_list.update({name:task})
    
    def _run(self):
        while True:
            start_t = time.time()
            for discoverier in self._discovery_list:
                discoverier()
            consuming_time=int(time.time()-start_t)
            gevent.sleep(self.run_interval-consuming_time)
    
                

class Agent(object):
    def __init__(self,**kwarg):
        self.checker_list=[]
        self.server=None
        self.sender=None
        self._checker_list=[]
        self._facter_list=[]
        self._discovery_list=[]
        for k,v in kwarg.items():
            setattr(self, k, v)
    
    def run_checker(self):
        #start worker thread pool
        #这段代码需要再分析一下
        
        self._checker_list=Collector()
        
        for checker in self._checker_list:
            ck=self._checker_list[checker].Checker()
            #非单例的使用方式
            #ck2=cc[checker].Checker(_name="test")
            ck.spawn()
            self.checker_list.append(ck)        
    
    def run_facter(self):
        self._facter_list=Collector(collecttype="facter")
        for facter in self._facter_list:
            fact=self._facter_list[facter].Facter()
            for name in fact:
                print("%s: %s"%(name,fact[name]))
    
    def run_zbxtrapsender(self):
        self.sender=ResultsSender()
        self.sender.spawn(sender=sender.zbx.Sender,mType="items")
    
    def run_cmdserver(self):
        #需要添加配置读取代码
        self.server = StreamServer(('',10050), CommandRunner(), backlog=100000)
        self.server.init_socket()
        gevent.signal(signal.SIGQUIT, self.gevent_shutdown,self.checker_list,self.server,self.sender)
        gevent.signal(signal.SIGINT,self.gevent_shutdown,self.checker_list,self.server,self.sender)          
        self.server.start()
        self.server.start_accepting()
        self.server._stop_event.wait()
    
    def run_discovery(self):
        self._discoverier_list=Collector(collecttype="discovery")
        self._discover_runner_list={}
        for discoverier in self._discoverier_list:
            #get run_interval and then init
            # ....
            run_interval=0
            discover = self._discoverier_list[discoverier].Discovery(run_interval=run_interval)
            if self._discoverier_list.has_key(discoverier):
                self._discoverier_list.update({run_interval:{discoverier:discover}})
            else:
                self._discoverier_list[run_interval].update({discoverier:discover})
            
    
    def gevent_shutdown(self,checker_list,server,sender):
        gevent.killall(self.checker_list)
        server.stop()
        gevent.killall([sender])
    
    @classmethod
    def main(cls):
        agent=cls()
        agent.run_checker()
        agent.run_zbxtrapsender()
        agent.run_facter()
        agent.run_cmdserver()
    
    
        

if __name__ == "__main__":
    Agent.main()